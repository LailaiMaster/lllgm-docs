![图片](https://uploader.shimo.im/f/1cb1RoVSwC0VF5Cv.png!thumbnail)

# 定义：

![图片](https://uploader.shimo.im/f/FqWmkwYCmGkPWRGc.png!thumbnail)


![图片](https://uploader.shimo.im/f/ofwDS1rcNbsH6MNr.png!thumbnail)


## 1.普通二叉树

## 2.满二叉树

## 3.完全二叉树

（最后一排靠左，除了最后一排，铺满）


如果用数组表示二叉树

![图片](https://uploader.shimo.im/f/tq6CqFs070AETha9.png!thumbnail)

A的左子树的索引位置2*i 右子树 2*i+1

ex：B数的左子树 2*2=4  右子树5.

上面这个是完全二叉树，因此我们之浪费了0这个所以一个位置，如果不是完全二叉树

![图片](https://uploader.shimo.im/f/gZLe38Qdk4I5CX6g.png!thumbnail)

所以 完全二叉树这个定义 其实是随着存储结构定义的。

# 遍历

![图片](https://uploader.shimo.im/f/dHj8GexqpGkjUMvE.png!thumbnail)

二叉树遍历的时间复杂度是 O(n)

# 二叉查找树

支持动态数据集合的快速插入、删除、查找操作

**二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值**

![图片](https://uploader.shimo.im/f/xXevGH5BR6sxqIGX.png!thumbnail)

## 查找

根节点直接返回，如果查找的数据小于根节点，查左树，大于查右树、

## 插入

如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。

```
public void insert(int data) {
  if (tree == null) {
    tree = new Node(data);
    return;
  }
 
  Node p = tree;
  while (p != null) {
    if (data > p.data) {
      if (p.right == null) {
        p.right = new Node(data);
        return;
      }
      p = p.right;
    } else { // data < p.data
      if (p.left == null) {
        p.left = new Node(data);
        return;
      }
      p = p.left;
    }
  }
}
```
![图片](https://uploader.shimo.im/f/NlhKjqrYGKctS09O.png!thumbnail)

## 删除

第一种情况是，如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为 null。比如图中的删除节点 55。

第二种情况是，如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。比如图中的删除节点 13。

第三种情况是，如果要删除的节点有两个子节点，这就比较复杂了。我们**需要找到这个节点的右子树中的最小节点**，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。比如图中的删除节点 18。

![图片](https://uploader.shimo.im/f/YtWCWITO8xkIDjlH.png!thumbnail)

```
public void delete(int data) {
  Node p = tree; // p 指向要删除的节点，初始化指向根节点
  Node pp = null; // pp 记录的是 p 的父节点
  while (p != null && p.data != data) {
    pp = p;
    if (data > p.data) p = p.right;
    else p = p.left;
  }
  if (p == null) return; // 没有找到
 
  // 要删除的节点有两个子节点
  if (p.left != null && p.right != null) { // 查找右子树中最小节点
    Node minP = p.right;
    Node minPP = p; // minPP 表示 minP 的父节点
    while (minP.left != null) {
      minPP = minP;
      minP = minP.left;
    }
    p.data = minP.data; // 将 minP 的数据替换到 p 中
    p = minP; // 下面就变成了删除 minP 了
    pp = minPP;
  }
 
  // 删除节点是叶子节点或者仅有一个子节点
  Node child; // p 的子节点
  if (p.left != null) child = p.left;
  else if (p.right != null) child = p.right;
  else child = null;
 
  if (pp == null) tree = child; // 删除的是根节点
  else if (pp.left == p) pp.left = child;
  else pp.right = child;
}
```
散列表和二叉查找树

散列表的查找，插入，删除时间复杂度都是O(1)，而二叉查找树理论情况下O(logn)，二叉查找树的存在意义在哪里？

1.散列表无法有序输出，必须排序后输出，而二叉查找树直接中序遍历出来，就是有序数列。

2.散列表扩容耗时，冲突时，不稳定。

3.虽然散列表O(1)，但是加上散列冲突，散列函数，效率不一定就比二叉树高

4.散列表构造比较复杂，考虑到哈希函数，冲突，扩容等。

5.装载因子不能过大，不然浪费空间

# 红黑树

红黑树和平衡二叉树。

我们知道不平衡的二叉树，可能退化成单链表，时间复杂度也退化为O(n)，所以尽量使树变平衡，是提高效率的关键，他要求**二叉树中任意一个节点的左右子树的高度相差不能大于 1。**

**红黑树的要求：**

* 根节点是黑色的；
* 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；
* 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
* 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；



目录

* [１ 引言](https://www.cnblogs.com/JoZSM/p/11784163.html#%E5%BC%95%E8%A8%80)
* [2 从二叉查找树到红黑树的演变](https://www.cnblogs.com/JoZSM/p/11784163.html#%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E5%88%B0%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%BC%94%E5%8F%98)
  * [2.1 二叉查找树](https://www.cnblogs.com/JoZSM/p/11784163.html#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91)
  * [2.2 平衡二叉查找树](https://www.cnblogs.com/JoZSM/p/11784163.html#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91)
  * [2.3 2-3树](https://www.cnblogs.com/JoZSM/p/11784163.html#%E6%A0%91)
  * [2.4 红黑树](https://www.cnblogs.com/JoZSM/p/11784163.html#%E7%BA%A2%E9%BB%91%E6%A0%91)
# １ 引言

RB-Tree，即红黑树，它的定义如下：

1. 这是一颗二叉树，且每个节点要么是红色、要么是黑色
2. 根节点是黑色
3. 叶子节点也是黑色的，且叶子节点不存储数据，即叶子节点是nil空节点
4. 不能出现连续的红色节点，即相邻的红色节点必须被黑色节点隔开
5. 任何一个节点到达其任意一个叶子节点均包含相同数目的黑色节点

单看上面的定义，大家肯定跟我一样一头雾水，别急，下面我们从最简单的二叉查找树说起，慢慢撕开这个高级数据结构的神秘面纱。

# 2 从二叉查找树到红黑树的演变

## 2.1 二叉查找树

一棵二叉查找树，每个节点的左节点均比当前节点小，且右节点均比当前节点大。上图的两棵树，均属于二叉查找树。于是，查找的过程如下：

* 当前节点等于目标值时，查找成功
* 当查找到空节点时，查找结束，返回不成功
* 小于时，继续在左子树中查找
* 大于时，继续在右子树中查找

最好的情况下，上图左侧示例，当所有节点的左右子树的高度都相同时，无论查找值是什么，每遍历一个节点都能排除一半的可能，这种情况的时间复杂度是O(logN)

最坏的情况下，上图右侧示例，当所有节点都集中在一条路径上，此时二叉查找树已经退化为一个链表，时间复杂度增大到O(N)

随着不断的增删操作，二叉查找树的时间复杂度变得不可控，介于O(logN)和O(N)之间。

有没有可能一直控制在最好的情况下呢，请看下一节：平衡二叉查找树

## 2.2 平衡二叉查找树

上一节讲到二叉查找树在最坏情况下会退化为链表，如果能保证每个节点的左右子树都是平衡的，即任意节点的左右子树的高度差均不大于1，那么查找的时间复杂度可以稳定在O(logN)。这就是平衡二叉查找树。

平衡二叉查找树的时间复杂度稳定在O(logN)。

但它同时给插入和删除操作带来了麻烦，每次插入或删除后，我们均需要确认这次操作是否影响了整棵树的平衡性，并在全局范围内作出适当调整。这种全局性对编码要求很高，难以实现且不说，额外的维持平衡的逻辑也大大增加了每次插入或删除的消耗，时间复杂度并不比普通二叉查找树优秀。

所以接下来大家不难想到，能否设计一种数据结构能够把全局的平衡性调整简化为局部的调整，从而简化代码实现难度，进而也降低时间复杂度？我们继续看下一节：2-3树

## 2.3 2-3树

2-3树是由2节点或3节点组成的树结构。这里的2或3指的是每个节点的子树数量：

* 2节点：保存1个key，左子树均小于key，右子树均大于key
* 3节点：保存2个key，左子树均小于最小key，中子树介于两个key之间，右子树均大于key
* 相应的，我们可以得出4节点的定义，即保存3个key，同时划分出4个区间对应于4棵子树

一棵完整的2-3树，高度平衡，即任意节点到达其任意叶子节点的路径长度均相同，也即任意叶子节点的深度是相同的。所以一棵完整的2-3树，就是一棵满的2叉和3叉树，复杂度：

* 最好情况：整棵树均由3节点组成，每遍历一个节点能排除2/3的数据，时间复杂度是 2/3 O(logN)
* 最坏情况：整棵树均由2节点组成，就是一棵满的平衡二叉树，时间复杂度是O(logN)

完整的2-3树的查找时间复杂度：O(logN)

接下来我们以插入操作为例，来看看2-3树是怎么把平衡二叉树要求的全局平衡性调整简化为局部的调整：

![图片](https://uploader.shimo.im/f/RZobtMveLXo1MOyG.png!thumbnail)

**对单个节点的插入处理**(如上图)

1. 插入S到空节点：直接生成S节点（这一步只可能发生在整棵树为空时。**二叉树的插入是在叶子节点后插入一个新节点，树是自顶向下生长的；而2-3树则要求**）
2. 插入H到2节点：得到一个3节点(H S)
3. 插入K到3节点：
3.1 得到一个临时4节点(H K S)
3.2 临时4节点裂变成3个2节点：将中间key拿出来得到K节点，最小/最大key分别为K节点的左右子节点
**注意**：*第1步只可能发生在整棵树为空时。*

* **二叉树是自顶向下生长**：插入操作是在叶子节点后新建一个子节点
* **2-3树是自底向上生长**：数据插入有值的叶子节点中，随着插入不断进行，底层节点不断往上裂变，直到根节点由4节点裂变成3个2节点时，树高才会+1

![图片](https://uploader.shimo.im/f/FNZkjxutVDoXyr2u.png!thumbnail)

**插入操作在一棵树内的处理**(如上图)

4.将D节点插入一棵现有的树时，会触发自底向上的递归式调整：

4.1 得到一个临时4节点node1(A B D)

4.2 node1裂变，由于父节点(H S)已存在，所以中间key插入到父节点，又得到一个临时节点node2(B H S)

4.3 node2裂变，由于Node2就是根节点，所以整棵树的高度+1，新的根节点是node2的中间key(H)

上面的1/2/3/4这4个步骤，即是对一棵2-3树的插入操作可能涉及的情况，不难发现，对2-3树的插入可以是一个递归过程，每次只处理单个节点即局部的逻辑，整棵树是自平衡的。递归逻辑如下：

* 根节点为空时，在根节点中插入key
* 根节点非空时：
* 先执行搜索，找到相同的key则替换；
* 未找到key时，将key插入当前节点，即查找的最后一个节点：
A. 当前节点为2节点，则插入后得到一个3节点，结束递归
B. 当前节点为3节点，则插入后得到一个4节点，裂变： a. 当前节点为根节点，则裂变后结束递归 b. 否则，将中间key拿出插入到当前节点的父节点，以父节点作为当前节点继续第A步

2-3树的删除操作在此省略。

**现在我们知道2-3树在平衡二叉树的基础上进行了优化，保持平衡即查找复杂度O(logN)的同时能够将每次的调整都控制在局部范围内。但2-3树的实现需要处理两种类型的节点，即2节点和3节点，这就增加了代码实现的复杂度，同时这个复杂的代码引起的消耗也不小，所以2-3树的插入或删除时的时间复杂度还不够理想。**

**所以接下来就是重头戏了，能否用一种节点来实现2-3树，即用二叉树来实现2-3树，将查找、插入、删除、修改的时间复杂度都控制在一个合理的O(logN)？**

## 2.4 红黑树

上一节的2-3树，其中的3节点如果我们用一个红黑的链接来表示，那么一棵2-3树可以转换成这样：

![图片](https://uploader.shimo.im/f/hggYzHQ4NQcBqAt9.png!thumbnail)

上图中我们对一棵2-3树作了处理，2节点固定为黑色，而3节点可以分解为2个用红色链接连接的2节点，然后将红色链接指向的孩子节点标记为红色，其他节点默认为黑色。

**2-3-4树**，按2-3树的思路，再增加一种4节点，1个4节点可以存储3个key，分裂时取中间元素向上冒，即是2-3-4树。4节点按二叉树的画法时，左右key都转换成红色节点。

**红黑树既是二叉搜索树，又是特殊的2-3-4树**，现在我们再以2-3-4树的性质来分析红黑树的定义，就容易理解了：

1. 这是一颗二叉树，且每个节点要么是红色、要么是黑色
2. 根节点是黑色
3. 叶子节点也是黑色的，且叶子节点不存储数据，即叶子节点是nil空节点
4. 不能出现连续的红色节点，即相邻的红色节点必须被黑色节点隔开
5. 任何一个节点到达其任意一个叶子节点均包含相同数目的黑色节点

第1条略过。

第3条是为了后续代码实现的便利性而设定的要求

第2/4条，其实是因为根据上面的转换方式，一个3/4节点分解成一个黑色的父节点和1/2个红色的孩子节点，那么红色节点一定会存在一个黑色的父节点。于是根节点没有父节点所以只能是黑色；红色节点的父节点一定是黑色的所以不可能存在相邻的红色节点。

第5条也好理解，正是将红色节点去除，即复原3/4节点后，能够得到一棵完整的2-3-4树，树的每个节点的左右子树的高度相等。

红黑树以二叉树的结构实现了一棵特殊的2-3-4树，由于拆分了3/4节点，所以树高增加了，那么查找的时间复杂度还有保证吗？

* 最好的情况：所有节点的左右子树的高度一致时，就是一棵满的平衡二叉树，时间复杂度是O(logN)
* 最坏的情况：红黑树最不平衡的状态就是本节开头画的那棵，红色节点全部集中在一条链路上。这时查找只有黑色节点的分支时，需要遍历的节点数小于O(logN)，时间复杂度就是O(logN)。查找红色节点所在的分支时，由于红色节点总是被黑色节点隔开，所以查找路径需要经历的红色节点数最大等于黑色节点数，而根据红黑树定义第5条，从根节点到叶子节点的任意路径的黑色节点固定，同样也小于O(logN)，所以最坏的时间复杂度是小于O(logN)乘以2的。可以认为最坏的时间复杂度近似于O(logN)

所以红黑树的查找时间复杂度稳定在O(logN)。



# 简介2-3-4树与红黑树的关系

2-3-4树与红黑树是多叉树与二叉树的关系，看上去完全不同，但是在某种意义上它们又是完全相同的，一个可以通过应用一些简单的规则变成另一个，而且使他们保持平衡的操作也是一样，数学上称他们为同构。

①转化规则

应用如下三条规则可以将2-3-4树转化为红黑树：

一、把2-3-4树中的每个2-节点转化为红黑树的黑色节点。

二、把每个3-节点转化为一个子节点和一个父节点，子节点有两个自己的子节点：W和X或X和Y。父节点有另一个子节点：Y或W。哪个节点变成子节点或父节点都无所谓。子节点涂成红色，父节点涂成黑色。

三、把每个4-节点转化为一个父节点和两个子节点。第一个子节点有它自己的子节点W和X；第二个子节点拥有子节点Y和Z。和  前面一样，子节点涂成红色，父节点涂成黑色。

![图片](https://uploader.shimo.im/f/hExWloUYCg0Rlc82.png!thumbnail)

下图是一颗2-3-4树转化成对应的红黑树。虚线环绕的子树是由3-节点和4-节点变成的。转化后符合红-黑树的规则，根节点为红色，两个红色节点不会相连，每条从根到叶节点的路径上的黑节点个数是一样的。

![图片](https://uploader.shimo.im/f/qyN7LnSj9roYUPWG.png!thumbnail)


②操作等价

不仅红黑树的结构与2-3-4树对应，而且两种树操作也一样。2-3-4树用节点分裂保持平衡，红黑树通过着色和旋转保持平衡。

![图片](https://uploader.shimo.im/f/xrdcPfup4sU63J4N.png!thumbnail)

上图是4-节点分裂。虚线环绕的部分等价于4-节点。**颜色变换之后，40，60节点都为黑色的，50节点是红色的**。因此节点50和它的父节点70对于3-节点，如上图虚线所示。

2-3-4树性能

分析2-3-4树我们可以和红黑树作比较。红黑树的层数大约是log2(N+1)，而2-3-4树每个节点可以最多有4个数据项，如果节点都是满的，那么高度为log4N。因此在所有节点都满的情况下，2-3-4树的高度大致是红黑树的一半。不过他们不可能都是满的，所以2-3-4树的高度大致在log2(N+1)和log2(N+1)/2。减少2-3-4树的高度可以使它的查找时间比红黑树的短一些。

但是另一方面，每个节点要查看的数据项就多了，这会增加查找时间。因为节点中用线性搜索来查看数据项，使得查找时间的倍数和M成正比，即每个节点数据项的平均数量，总的查找时间和M*log4N成正比。

# 理解

在线模拟

[https://www.cs.usfca.edu/~galles/visualization/RedBlack.html](https://www.cs.usfca.edu/~galles/visualization/RedBlack.html)

12  1  9   2 

顺序add

红黑树

![图片](https://uploader.shimo.im/f/L6Y0T6CExmajDoaY!thumbnail)

2-3-4树

12

 

