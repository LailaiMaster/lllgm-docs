**散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。**![图片](https://uploader.shimo.im/f/9zmzAl0uRN4cy4yE.png!thumbnail)

# **散列函数**
散列函数设计的基本要求：

1.得到的值是一个非负整数。

2.如果key1==key2，那么hash(key1)=hash(key2)

3.如果key1!=key2，那么hash(key1)!=hash(key2)

第三点几乎不可能实现，散列冲突。

# 散列冲突
## 1.开放寻址法

核心思想是，如果出现了散列冲突，就重新探测一个位置插入。

### 1.线性探测

![图片](https://uploader.shimo.im/f/RfdCLic8JZYLYvbM.png!thumbnail)

查找，算出key取出的元素相同，说明取到了，如果不相等，则继续往下找，知道遇到下一个空位，如果没有找到，该元素不在散列表中。

![图片](https://uploader.shimo.im/f/gOQvRKAW3Qke7pdk.png!thumbnail)

开放寻址法的问题是，如果数据越来越多，空位很少，我们查找的时候，可能要探测整个表，时间复杂度会变成O(n)。

### 2.二次探测

二次探测和线性探测很像，线性探测是每次探测步长是1，而二次探测的步长是原来的二次方。

1^2,2^2

### 3.双重散列

不只有一个hash函数，而是一组，当第一个hash函数冲突时，就使用第二个hash函数计算。


不管哪种探测方法，当散列表中空位不多时，散列冲突的概率就会变大，一般情况下，我们都要保证，散列表中要有一定比例的空闲位置。我们用**装载因子**表示空位的多少。

装载因子=表中个数/散列表容量

## 2.链表法

![图片](https://uploader.shimo.im/f/GWXjpN2eMX47Z7f1.png!thumbnail)

在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。


# 如何设计散列表
1.散列函数不能设计的太复杂

2.散列函数得到值尽可能的分布

3.动态扩容

# 为什么散列表经常和链表一起使用
# 1.LRU缓存淘汰算法

单纯使用链表实现lru算法，我们需要维护一个按照访问时间从大到小有序排列的链表结构。因为缓存大小有限，当缓存空间不够，需要淘汰一个数据的时候，我们就直接将链表头部的结点删除。

当要缓存某个数据的时候，先在链表中查找这个数据。如果没有找到，则直接将数据放到链表的尾部；如果找到了，我们就把它移动到链表的尾部。因为查找数据需要遍历链表，所以单纯用链表实现的 LRU 缓存淘汰算法的时间复杂很高，是 O(n)。

因为涉及到查找，链表查找复杂度O(n)，我们可以使用散列表，将查找的时间复杂度降低为O(1)

![图片](https://uploader.shimo.im/f/ZruL0QIMxqExHa6V.png!thumbnail)

双向列表，除了prev和next，增加了一个hnext，这个指针用来相同hash值的拉链。


查找：

借助散列表，查找到一个元素，复杂度接近O(1)，找到后，我们还要把元素移到链表尾部。

删除：

借助散列表，查找到元素，因为是双向链表，删除一个元素，复杂度接近O(1)。

插入：

添加数据到缓存稍微有点麻烦，我们需要先看这个数据是否已经在缓存中。如果已经在其中，需要将其移动到双向链表的尾部；如果不在其中，还要看缓存有没有满。如果满了，则将双向链表头部的结点删除，然后再将数据放到链表的尾部；如果没有满，就直接将数据放到链表的尾部。



